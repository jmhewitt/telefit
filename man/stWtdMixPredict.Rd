% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stWtdMixPredict.R
\name{stWtdMixPredict}
\alias{stWtdMixPredict}
\title{Compute forecasts based on posterior samples}
\usage{
stWtdMixPredict(stData, stDataNew, priors, coords.knots, miles,
  conf = 0.95, tLabs = stDataNew$tLabs, X = stData$X, Y = stData$Y,
  Z = stData$Z, Xnew = stDataNew$X, Znew = stDataNew$Z,
  coords.s = stData$coords.s, coords.r = stData$coords.r,
  cat.probs = c(1/3, 2/3), level = 2, ncores = 1,
  w.control = list(method = "Nelder", maxit = 50000))
}
\arguments{
\item{stData}{Object with class 'stData' containing data needed to fit this
model. The data need only be manually entered if not using a stData object.}

\item{stDataNew}{object of class stData that includes information needed for
making forecasts.  If response data is included, this function will
automatically run stEval using the empirical climatology as the reference
forecast}

\item{priors}{A list containing parameters for the prior distributions. The
 list needs to contain the following values
   \describe{
     \item{beta}{ list(Lambda=matrix) specifying the prior covariance matrix
       for the local effects if varying==F, otherwise
       list(Psi=matrix, nu=double) specifying the Inverse wishart prior
       distribution for the spatially varying coefficient process if
       varying==T. }

     \item{cov.s}{ list(smoothness=double, range=c(min, max),
       variance=c(shape, rate), nugget=c(shape, rate)) }

     \item{cov.r}{ list(smoothness=double, range=c(min, max),
       variance=c(shape, rate), nugget=c(shape, rate)) }
   }}

\item{coords.knots}{matrix with coordinates where remote teleconnections
will be based (lon, lat)}

\item{miles}{TRUE if covariance matrix distances should be in miles, FALSE
for kilometers}

\item{conf}{Parameter specifying the prediction interval}

\item{tLabs}{Forecast timepoint labels}

\item{X}{[ns, p, nt] array of design matrices with local covariates}

\item{Y}{[ns, nt] matrix with response data}

\item{Z}{[nr, nt] matrix with remote covariates}

\item{Xnew}{[ns, p, nt0] array of design matrices with local covariates
at forecast timepoints}

\item{Znew}{[nr, nt0] matrix with remote covariates at forecast timepoints}

\item{coords.s}{matrix with coordinates where responses were
observed (lon, lat)}

\item{coords.r}{matrix with coordinates where remote covariates
were observed (lon, lat)}

\item{cat.probs}{vector of probabilities for also returning categorical
predictions from the posterior prediction samples; NULL otherwise}

\item{level}{set the quadrature integration level used by wtdMix}

\item{ncores}{Since the teleconnection effects and posterior predictions can
be sampled in parallel, this parameter lets users specify the number of
cores to use to draw teleconnection and prediction samples}

\item{w.control}{list of control parameters for the optimization used to 
build the quadrature integration}
}
\description{
Predict response at new timepoints by using weighted mixtures to approximate
the posterior predictive distribution.
}
\examples{
# load data
data("coprecip")
data("coprecip.fit")

#
# subset data so that demonstration is fast
#

# subsample spatial coordinates
inds.s = sample(nrow(coprecip$coords.s), 10)
inds.r = sample(nrow(coprecip$coords.r), 100)
inds.knots = sample(nrow(coprecip.fit$coords.knots), 10)

# train model on two timepoints
inds.t = 1:2

coprecip.fit$coords.knots = coprecip.fit$coords.knots[inds.knots,]

coprecip.new = coprecip
coprecip.new$coords.s = coprecip.new$coords.s[inds.s,]
coprecip.new$coords.r = coprecip.new$coords.r[inds.r,]
coprecip.new$X = coprecip.new$X[inds.s,, -inds.t, drop = FALSE]
coprecip.new$Y = coprecip.new$Y[inds.s, -inds.t, drop = FALSE]
coprecip.new$Z = coprecip.new$Z[inds.r, -inds.t, drop = FALSE]
coprecip.new$tLabs = coprecip.new$tLabs[-inds.t]

coprecip$coords.s = coprecip$coords.s[inds.s,]
coprecip$coords.r = coprecip$coords.r[inds.r,]
coprecip$X = coprecip$X[inds.s,, inds.t, drop = FALSE]
coprecip$Y = coprecip$Y[inds.s, inds.t, drop = FALSE]
coprecip$Z = coprecip$Z[inds.r, inds.t, drop = FALSE]
coprecip$tLabs = coprecip$tLabs[inds.t]


#
# build weighted mixture
#

fit.wtdMix = stWtdMixPredict(stData = coprecip, stDataNew = coprecip.new,
                             priors = coprecip.fit$priors, 
                             coords.knots = coprecip.fit$coords.knots, 
                             miles = coprecip.fit$miles,
                             w.control = list(method = 'Nelder', maxit = 1))
}

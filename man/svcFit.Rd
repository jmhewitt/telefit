% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/svcFit.R
\name{svcFit}
\alias{svcFit}
\title{Fit a spatially varying coefficient model}
\usage{
svcFit(y, X, z, coords, miles = T, priors, nSamples, thin = 1,
  rw.initsd = 0.1, inits = list(), C = 1, alpha = 0.44)
}
\arguments{
\item{y}{vector containing responses for each timepoint.  vector is blocked
by timepoint.}

\item{X}{matrix containing local covariates for each timepoint.  each row
are the covariates for one location and timepoint.  matrix is blocked by
timepoint.}

\item{z}{matrix containing remote covariates.  each column has remote 
covariates for one timepoint.}

\item{coords}{n x 2 matrix containing lon-lat coordinates for locations.}

\item{miles}{T/F for whether to compute great circle distances in miles (T)
or km (F)}

\item{priors}{A list containing parameters for the prior distributions. The
list needs to contain the following values:
  \describe{
    \item{T}{ list(Psi=matrix, nu=double) specifying the Inverse wishart 
              prior distribution for the spatially varying coefficient 
              process. }
    \item{beta}{ list(Linv=matrix) specifying the prior precision matrix 
                 for the fixed local covariates. }
    \item{sigmasq}{ list(a=double, b=double) specifying the prior shape and
                    scale parameters for the covariance scale and nugget 
                    parameters. }
    \item{rho}{ list(L=double, U=double) specifying the lower and upper 
                bounds for the spatial range parameter. }
    \item{cov}{ list(nu=double) specifying the smoothness for the 
                matern covariance.}
  }}

\item{nSamples}{number of MCMC iterations to run}

\item{thin}{MCMC thinning; defaults to no thinning (thin=1)}

\item{rw.initsd}{Initial proposal standard deviation for RW samplers}

\item{inits}{optional list containing starting parameters for MCMC sampler}

\item{C}{scaling factor used in adapting random walk proposal variances.}

\item{alpha}{target acceptance rate for random walk proposals.}
}
\description{
Fit a spatially varying coefficient model
}
\examples{
\dontrun{ 
  
# demonstration of svcFit and svcPredict methods for spatially varying 
# coefficient models with remote effects.
#
# this example may take several minutes to run.  additionally, the MCMC sample
# paths for the covariance parameters sigmasq, sigmasqeps, and rho have large
# autocorrelation. this example is mainly for code demonstration purposes only
# since this example does not remedy this issue.

library(telefit)
library(fields)
library(mvtnorm)

set.seed(2018)


# helper sampling functions
kronSamp = function(A, B) {
  y = matrix(0, nrow = nrow(A) * nrow(B), ncol=1)
  .Call(`_telefit_r_mvrnorm_postKron`, y, solve(A), solve(B), 1, TRUE)
}
invWSamp = function(Psi, n) {
  .Call(`_telefit_r_mc2_rinvwishart`, Psi, n)
}


# set key parameters
dims = list(N=200, nt=30, k=2, p=2)
params = list(sigmasq=.2, rho=.3, eps=.5, nu=.5)


# generate parameters and data
coords = matrix( runif(2 * dims$N), ncol = 2 )
X = matrix( rnorm(dims$p * dims$N * dims$nt), ncol = dims$p )
beta = c(-1, .5)
z = matrix( rnorm(dims$k * dims$nt), ncol = dims$nt)
H = maternCov(rdist.earth(coords), scale = params$sigmasq, range = params$rho,
              smoothness = params$nu, nugget = params$sigmasq * params$eps)
Hinv = solve(H)
Tm = matrix(c(.5,.2, .2, .5), ncol=2)/2
theta = kronSamp(Hinv, Tm)


# generate response
xb = X \%*\% beta
zt = as.numeric(apply(z, 2, function(d) { 
  kronecker(diag(dims$N), t(d)) \%*\% theta }))
w = kronSamp(diag(dims$nt), H)
y =  xb + zt + w


# view response and components

par(mfrow=c(2,2))
hist(y)
hist(xb)
hist(zt)
hist(w)

quilt.plot(y[1:dims$N], coords, main = 'y')
quilt.plot(xb[1:dims$N], coords, main = 'xb')
quilt.plot(zt[1:dims$N], coords, main = 'zt')
quilt.plot(w[1:dims$N], coords, main = 'w')


# fit model
it = 4e3
priors = list(
  T = list(Psi = .1*diag(dims$k), nu = dims$k),
  beta = list(Linv = diag(dims$p) * 1e-2),
  sigmasq = list(a=2, b=1),
  rho = list(L=0, U=1),
  cov = list(nu=.5)
)

fit = svcFit(y=y, X=X, z=z, coords=coords, priors=priors, nSamples=it)


# check convergence
library(coda)
burn = 1e3/2

par(mfrow=c(1,1))

plot(mcmc(fit$parameters$samples$beta[-(1:burn),]))

plot(theta, colMeans(fit$parameters$samples$theta[-(1:burn),]))
cor(theta, colMeans(fit$parameters$samples$theta[-(1:burn),]))
abline(0,1)

plot(mcmc(fit$parameters$samples$T[-(1:burn),1:2]))
cor(as.numeric(Tm), colMeans(fit$parameters$samples$T[-(1:burn),]))

# very slow sampler for covariance scales
plot(mcmc(fit$parameters$samples$sigmasq[-(1:burn),]))
summary(mcmc(fit$parameters$samples$sigmasq[-(1:burn),]))
effectiveSize(mcmc(fit$parameters$samples$sigmasq[-(1:burn),]))
acf(mcmc(fit$parameters$samples$sigmasq[-(1:burn),]), lag.max = 2e2)

plot(mcmc(fit$parameters$samples$rho[-(1:burn),]))
summary(mcmc(fit$parameters$samples$rho[-(1:burn),]))
HPDinterval(mcmc(fit$parameters$samples$rho[-(1:burn),]))
effectiveSize(mcmc(fit$parameters$samples$rho[-(1:burn),]))

plot(mcmc(fit$parameters$samples$sigmasqeps[-(1:burn),]))
summary(mcmc(fit$parameters$samples$sigmasqeps[-(1:burn),]))
effectiveSize(mcmc(fit$parameters$samples$sigmasqeps[-(1:burn),]))


#
# predict at new timepoints
#

# generate parameters and data
nt0 = dims$nt/2
Xn = matrix( rnorm(dims$p * dims$N * nt0), ncol = dims$p )
zn = matrix( rnorm(dims$k * nt0), ncol = nt0)

# generate response
xbn = Xn \%*\% beta
ztn = as.numeric(apply(zn, 2, function(d) { 
  kronecker(diag(dims$N), t(d)) \%*\% theta }))
wn = kronSamp(diag(nt0), H)
yn =  xbn + ztn + wn

# predict responses
pred = svcPredict(fit, Xn, zn, burn = burn)
yh = colMeans(mcmc(pred$y[-(1:burn),]))

# R^2
1 - var(yh - yn)/var(yn)

# coverage
yh.hpd = HPDinterval(mcmc(pred$y[-(1:burn),]))
coverage = numeric(length(yn))
for(i in 1:length(coverage))
  coverage[i] = (yh.hpd[i,1] <= yn[i]) && (yh.hpd[i,2] >= yn[i])
mean(coverage)

# example posterior densities
plot(mcmc(pred$y[-(1:burn),1:2]))

# example posterior densities overlapped with response
par(mfrow=c(2,2))
for(i in 1:4) {
  plot(density(pred$y[-(1:burn),i]), main=i)
  abline(v = yn[i], lty=3)
}

# visually compare point predictions
par(mfrow=c(1,2))
quilt.plot(yn[1:dims$N], coords, main = 'ynew')
quilt.plot(yh[1:dims$N], coords, main = 'yhat')

}
}
